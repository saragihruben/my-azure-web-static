"use strict";

exports.__esModule = true;
exports.default = void 0;
var _react = _interopRequireWildcard(require("react"));
var _reactWaypoint = require("react-waypoint");
var _Media = _interopRequireDefault(require("../Media"));
var _constants = require("../constants");
var _loaders = require("../loaders");
var _helpers = require("../helpers");
function _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e }; }
function _getRequireWildcardCache(e) { if ("function" != typeof WeakMap) return null; var r = new WeakMap(), t = new WeakMap(); return (_getRequireWildcardCache = function (e) { return e ? t : r; })(e); }
function _interopRequireWildcard(e, r) { if (!r && e && e.__esModule) return e; if (null === e || "object" != typeof e && "function" != typeof e) return { default: e }; var t = _getRequireWildcardCache(r); if (t && t.has(e)) return t.get(e); var n = { __proto__: null }, a = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var u in e) if ("default" !== u && {}.hasOwnProperty.call(e, u)) { var i = a ? Object.getOwnPropertyDescriptor(e, u) : null; i && (i.get || i.set) ? Object.defineProperty(n, u, i) : n[u] = e[u]; } return n.default = e, t && t.set(e, n), n; }
function _extends() { return _extends = Object.assign ? Object.assign.bind() : function (n) { for (var e = 1; e < arguments.length; e++) { var t = arguments[e]; for (var r in t) ({}).hasOwnProperty.call(t, r) && (n[r] = t[r]); } return n; }, _extends.apply(null, arguments); }
function ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }
function _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }
function _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == typeof i ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != typeof t || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != typeof i) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); } // import PropTypes from 'prop-types'
const {
  initial,
  loading,
  loaded,
  error
} = _constants.loadStates;
const defaultShouldAutoDownload = _ref => {
  let {
    connection,
    size,
    threshold,
    possiblySlowNetwork
  } = _ref;
  if (possiblySlowNetwork) return false;
  if (!connection) return true;
  const {
    downlink,
    rtt,
    effectiveType
  } = connection;
  switch (effectiveType) {
    case 'slow-2g':
    case '2g':
      return false;
    case '3g':
      if (downlink && size && threshold) {
        return size * 8 / (downlink * 1000) + rtt < threshold;
      }
      return false;
    case '4g':
    default:
      return true;
  }
};
const defaultGetMessage = (icon, state) => {
  switch (icon) {
    case _constants.icons.noicon:
    case _constants.icons.loaded:
      return null;
    case _constants.icons.loading:
      return 'Loading...';
    case _constants.icons.load:
      // we can show `alt` here
      const {
        pickedSrc
      } = state;
      const {
        size
      } = pickedSrc;
      if (size) {
        return ['Click to load (', /*#__PURE__*/_react.default.createElement("nobr", {
          key: "nb"
        }, (0, _helpers.bytesToSize)(size)), ')'];
      } else {
        return 'Click to load';
      }
    case _constants.icons.offline:
      return 'Your browser is offline. Image not loaded';
    case _constants.icons.error:
      const {
        loadInfo
      } = state;
      if (loadInfo === 404) {
        return '404. Image not found';
      } else {
        return 'Error. Click to reload';
      }
    default:
      throw new Error("Wrong icon: " + icon);
  }
};
const defaultGetIcon = state => {
  const {
    loadState,
    onLine,
    overThreshold,
    userTriggered
  } = state;
  if (_helpers.ssr) return _constants.icons.noicon;
  switch (loadState) {
    case loaded:
      return _constants.icons.loaded;
    case loading:
      return overThreshold ? _constants.icons.loading : _constants.icons.noicon;
    case initial:
      if (onLine) {
        const {
          shouldAutoDownload
        } = state;
        if (shouldAutoDownload === undefined) return _constants.icons.noicon;
        return userTriggered || !shouldAutoDownload ? _constants.icons.load : _constants.icons.noicon;
      } else {
        return _constants.icons.offline;
      }
    case error:
      return onLine ? _constants.icons.error : _constants.icons.offline;
    default:
      throw new Error("Wrong state: " + loadState);
  }
};
class IdealImage extends _react.Component {
  constructor(props) {
    super(props);
    // TODO: validate props.srcSet
    _defineProperty(this, "onClick", () => {
      const {
        loadState,
        onLine,
        overThreshold
      } = this.state;
      if (!onLine) return;
      switch (loadState) {
        case loading:
          if (overThreshold) this.cancel(true);
          return;
        case loaded:
          // nothing
          return;
        case initial:
        case error:
          this.load(true);
          return;
        default:
          throw new Error("Wrong state: " + loadState);
      }
    });
    _defineProperty(this, "load", userTriggered => {
      const {
        loadState,
        url
      } = this.state;
      if (_helpers.ssr || loaded === loadState || loading === loadState) return;
      this.loadStateChange(loading, userTriggered);
      const {
        threshold
      } = this.props;
      const loader = this.props.loader === 'xhr' ? (0, _loaders.xhrLoader)(url) : (0, _loaders.imageLoader)(url);
      loader.then(() => {
        this.clear();
        this.loadStateChange(loaded, false);
      }).catch(e => {
        this.clear();
        if (e.status === 404) {
          this.loadStateChange(error, false, 404);
        } else {
          this.loadStateChange(error, false);
        }
      });
      if (threshold) {
        const timeoutLoader = (0, _loaders.timeout)(threshold);
        timeoutLoader.then(() => {
          if (!this.loader) return;
          window.document.dispatchEvent(new CustomEvent('possiblySlowNetwork', {
            detail: {
              possiblySlowNetwork: true
            }
          }));
          this.setState({
            overThreshold: true
          });
          if (!this.state.userTriggered) this.cancel(true);
        });
        this.loader = (0, _loaders.combineCancel)(loader, timeoutLoader);
      } else {
        this.loader = loader;
      }
    });
    _defineProperty(this, "onEnter", () => {
      if (this.state.inViewport) return;
      this.setState({
        inViewport: true
      });
      const pickedSrc = (0, _helpers.selectSrc)({
        srcSet: this.props.srcSet,
        maxImageWidth: this.props.srcSet.length > 1 ? (0, _helpers.guessMaxImageWidth)(this.state.dimensions) // eslint-disable-line react/no-access-state-in-setstate
        : 0,
        supportsWebp: _helpers.supportsWebp
      });
      const {
        getUrl
      } = this.props;
      const url = getUrl ? getUrl(pickedSrc) : pickedSrc.src;
      const shouldAutoDownload = this.props.shouldAutoDownload(_objectSpread(_objectSpread({}, this.state), {}, {
        // eslint-disable-line react/no-access-state-in-setstate
        size: pickedSrc.size
      }));
      this.setState({
        pickedSrc,
        shouldAutoDownload,
        url
      }, () => {
        if (shouldAutoDownload) this.load(false);
      });
    });
    _defineProperty(this, "onLeave", () => {
      if (this.state.loadState === loading && !this.state.userTriggered) {
        this.setState({
          inViewport: false
        });
        this.cancel(false);
      }
    });
    this.state = {
      loadState: initial,
      connection: _helpers.nativeConnection ? {
        downlink: navigator.connection.downlink,
        // megabits per second
        rtt: navigator.connection.rtt,
        // ms
        effectiveType: navigator.connection.effectiveType // 'slow-2g', '2g', '3g', or '4g'
      } : null,
      onLine: true,
      overThreshold: false,
      inViewport: false,
      userTriggered: false,
      possiblySlowNetwork: false
    };
  }

  /*
    static propTypes = {
      /!** how much to wait in ms until concider download to slow *!/
      threshold: PropTypes.number,
      /!** function to generate src based on width and format *!/
      getUrl: PropTypes.func,
      /!** array of sources *!/
      srcSet: PropTypes.arrayOf(
        PropTypes.shape({
          width: PropTypes.number.isRequired,
          src: PropTypes.string,
          size: PropTypes.number,
          format: PropTypes.oneOf(['jpeg', 'jpg', 'webp', 'png', 'gif']),
        }),
      ).isRequired,
      /!** function which decides if image should be downloaded *!/
      shouldAutoDownload: PropTypes.func,
      /!** function which decides what message to show *!/
      getMessage: PropTypes.func,
      /!** function which decides what icon to show *!/
      getIcon: PropTypes.func,
      /!** type of loader *!/
      loader: PropTypes.oneOf(['image', 'xhr']),
      /!** Width of the image in px *!/
      width: PropTypes.number.isRequired,
      /!** Height of the image in px *!/
      height: PropTypes.number.isRequired,
      placeholder: PropTypes.oneOfType([
        PropTypes.shape({
          /!** Solid color placeholder *!/
          color: PropTypes.string.isRequired,
        }),
        PropTypes.shape({
          /!**
           * [Low Quality Image Placeholder](https://github.com/zouhir/lqip)
           * [SVG-Based Image Placeholder](https://github.com/technopagan/sqip)
           * base64 encoded image of low quality
           *!/
          lqip: PropTypes.string.isRequired,
        }),
      ]).isRequired,
      /!** Map of icons *!/
      icons: PropTypes.object.isRequired,
      /!** theme object - CSS Modules or React styles *!/
      theme: PropTypes.object.isRequired,
    }*/

  componentDidMount() {
    if (_helpers.nativeConnection) {
      this.updateConnection = () => {
        if (!navigator.onLine) return;
        if (this.state.loadState === initial) {
          this.setState({
            connection: {
              effectiveType: navigator.connection.effectiveType,
              downlink: navigator.connection.downlink,
              rtt: navigator.connection.rtt
            }
          });
        }
      };
      navigator.connection.addEventListener('onchange', this.updateConnection);
    } else if (this.props.threshold) {
      this.possiblySlowNetworkListener = e => {
        if (this.state.loadState !== initial) return;
        const {
          possiblySlowNetwork
        } = e.detail;
        if (!this.state.possiblySlowNetwork && possiblySlowNetwork) {
          this.setState({
            possiblySlowNetwork
          });
        }
      };
      window.document.addEventListener('possiblySlowNetwork', this.possiblySlowNetworkListener);
    }
    this.updateOnlineStatus = () => this.setState({
      onLine: navigator.onLine
    });
    this.updateOnlineStatus();
    window.addEventListener('online', this.updateOnlineStatus);
    window.addEventListener('offline', this.updateOnlineStatus);
  }
  componentWillUnmount() {
    this.clear();
    if (_helpers.nativeConnection) {
      navigator.connection.removeEventListener('onchange', this.updateConnection);
    } else if (this.props.threshold) {
      window.document.removeEventListener('possiblySlowNetwork', this.possiblySlowNetworkListener);
    }
    window.removeEventListener('online', this.updateOnlineStatus);
    window.removeEventListener('offline', this.updateOnlineStatus);
  }
  clear() {
    if (this.loader) {
      this.loader.cancel();
      this.loader = undefined;
    }
  }
  cancel(userTriggered) {
    if (loading !== this.state.loadState) return;
    this.clear();
    this.loadStateChange(initial, userTriggered);
  }
  loadStateChange(loadState, userTriggered, loadInfo) {
    if (loadInfo === void 0) {
      loadInfo = null;
    }
    this.setState({
      loadState,
      overThreshold: false,
      userTriggered: !!userTriggered,
      loadInfo
    });
  }
  render() {
    const icon = this.props.getIcon(this.state);
    const message = this.props.getMessage(icon, this.state);
    return /*#__PURE__*/_react.default.createElement(_reactWaypoint.Waypoint, {
      onEnter: this.onEnter,
      onLeave: this.onLeave
    }, /*#__PURE__*/_react.default.createElement(_Media.default, _extends({}, this.props, (0, _helpers.fallbackParams)(this.props), {
      onClick: this.onClick,
      icon: icon,
      src: this.state.url || '',
      onDimensions: dimensions => this.setState({
        dimensions
      }),
      message: message
    })));
  }
}
exports.default = IdealImage;
_defineProperty(IdealImage, "defaultProps", {
  shouldAutoDownload: defaultShouldAutoDownload,
  getMessage: defaultGetMessage,
  getIcon: defaultGetIcon,
  loader: 'xhr'
});